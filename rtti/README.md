# Реализация RTTI
Оценка: 2 балл.

## Задача
Чтобы получше понять RTTI в C++, попробуйте сами его реализовать.

Требуется реализовать:
DYNAMIC_CAST: механизм для down-cast преобразования указателей;
TYPEID: механизм для получения информации о классе (имя, хэш, возможность сравнения)
Систему макросов, которая будет включать поддержку RTTI для конкретного класса.
Поддержка множественного наследования.

## Рекомендации
1. Как обычно, рекомендуется “расширить язык” собственными макросами

2. Отключите поддержку RTTI при компиляции, чтобы убедиться, что работает именно то, что реализовано Вами.
  * В VisualStudio это делается через настройки проекта
    **C/C++ -> Language -> Enable Runtime Time Information: No**

  * В GCC есть аргумент командной строки
    **-fno-rtti**

## Решение

Для начала есть простой класс `CTypeId`, хранящий имя и хеш класса. Также есть класс `CTypeIdStorage` с единственным полем — `CTypeId`.

Для определения классов заведено два макроса `Class( имя класса )` и `ClassExtends( имя класса, база1, база2, ... )`. При их использовании создается класс указанным именем, причем он виртуально наследуется от класса `CTypeIdStorage`.

Информация о типе заполняется во время создания экземпляра класса. Это происходит в макросе `EnableRTTI( имя класса )`. Его нужно использовать внутри класса с указанным именем, при описании полей. Макрос заключается в создании поля типа `void*` (потому что это самый ниочемный завершенный тип), которому присваивается значение лямбда-функции с побочными эффектами. Побочным эффектом и является заполнение информации о типе, а также запоминание размера класса. Из размера класса при этом вычетается размер класса `CTypeIdStorage`, позже станет понятно почему.

Благодаря тому, что от `CTypeIdStorage( объект )` мы наследовались виртуально, то у каждого класса будет одна копия, и мы без проблема в макросе `TypeId` просто вернем значение поля. Кстати, стоит отметить, что мы разрешаем виртуальное наследование только в этом случае. Если в `ClassExtends` кто-то делает виртуальное наследование, то будет брошено исключение.

Переходим к `DynamicCast( имя типа-указателя, указатель на класс )`. Прежде всего стоит заметить, что в макросах `Class` и `ClassExtends` также создается глобальная переменная по тому же механизму, по которому мы заполминали тип и размер класса. Только на этот побочный эффект — добавление зависимостей между классами. Для них есть специальный мап: по имени класса получить вектор всех его родительских классов.

Также заводим специальную функцию, которая проверяет, можно ли скастовать один класс к другому. Она просто ходит по дереву и смотрит, если путь от одного класса к другому.

Наконец, нужно посчитать сдвиг для указателя. Это делается по такому алгоритму. Запоминаем некий текущий сдвиг, изначально 0. Берем первого родителя; если это наш класс, то все, надо вернуть сдвиг. Если это не наш класс, но от него можно скастоваться к нашему, то к текущему сдвигу прибавляем сдвиг от каста к тому родителю. Ну и если от этого нельзя даже кастоваться к нашему, то тогда переходим к следующему родителю, а сдвиг увеличиваем на размер того родительского класса.

Так как классы располагаются в памяти особым образом, то это корректно. Рассмотрим пример. Введем сокращение: `T = CTypeIdStorage`.
```C++
class A : virtual T;
class B : virtual T;
class C : virtual T, A, B;
class D : virtual T;
class E : virtual T;
class F : virtual T, D;
class G : virtual T, E, F;
class I : virtual T;
class J : virutal T : I;
class H : virutal T : J;
class L : virutal T : C, G, H;
```
Тогда классы будут лежать в памяти вот в таком порядке: `ABCDEFGHIJHLT`. Общий виртуальный родительский класс `T` самый последний. Именно поэтому мы не учитываем для сдвига размер `CTypeIdStorage`, а для нахождения сдвига годится простой обход по дереву.

Заметим, что тут важно, что ни от каких классов, кроме `T`, нет виртуального наследования, иначе все было бы сложно.
