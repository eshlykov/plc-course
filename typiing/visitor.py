# -*- coding: utf-8 -*-
"""Visitor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kTsyM-NUCD50OPUWwLfxIY8skd6VOJwi
"""

!apt-get -qq install -y graphviz && pip install -q pydot
from pydot import *

"""Хочется поговорить немного про типизацию, утиную и разную.

Поговорим в контексте простой задачи - DFS обхода.

Если задача кажется совсем скучной - [попробуйте реализовать backpropagation](https://colab.research.google.com/drive/1Qe11uLSUmpQNAM8cjQ8rTKVj-jN5AQH7).
"""

graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for vert in graph[start]:
        if vert not in visited:
            dfs(graph, vert, visited)
    return visited

dfs(graph, 'C')

"""Что, если хочется добавить какой-то полезный функционал в данный обход?

Для добавления этого функционала можно добавить колбэки на нужные события. Ограничимся пока входом в вершину (перекраска в серый цвет) и выходом из неё (перекраска в черный).

Какой функционал будем добавлять? Например, мне хочется визуализировать ход dfs.

Ну, саму визуализацию написать довольно просто:
"""

from IPython import display

def display_graph(pdot):
    display.clear_output(True)
    plt = display.Image(pdot.create_png())
    display.display(plt)


dot_graph = Dot(graph_type='graph')

for node in graph:
    dot_graph.add_node(Node(node, style='filled', fontcolor='red', fillcolor='white'))
  
for node_from in graph:
    for node_to in graph[node_from]:
        if not dot_graph.get_edge(node_from, node_to):
            dot_graph.add_edge(Edge(node_from, node_to))

dot_graph.get_node('A')[0].set_fillcolor('gray')

display_graph(dot_graph)

"""Напишите класс `VisualizationCallback`, который будет демонстрировать на каждом шаге dfs, как перекрашиваются вершины.

Сделаем ему такой интерфейс:
"""

import time

class VisualizationCallback:
    def __init__(self, graph):
        <build graph>
        display_graph(self.dot_graph)
        time.sleep(1)
  
    def discover_vertex(self, vertex):
        <the vertex is gray now>
        display_graph(self.dot_graph)
        time.sleep(1)
        
    def finish_vertex(self, vertex):
        <the vertex is black now>
        display_graph(self.dot_graph)
        time.sleep(1)

"""Заиспользуем его в `dfs`:"""

graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}

def dfs(graph, start, callback, visited=None):
    <implement dfs with callback>

callback = VisualizationCallback(graph)
dfs(graph, 'C', callback)

"""При чём здесь типизация?

Функция `dfs` пользуется неявным интерфейсом для `callback`: тем, что в нём есть методы `discover_vertex` и `finish_vertex`. Таким образом, нам помогает утиная типизация python. 

Но динамическая типизация в нем может привести к неприятному: что, если мы передадим колбэк без метода `finish_vertex`. Алгоритм может обработать тысячу вершин, прежде чем узнает, что такого метода нет.

А как то же самое можно сделать в языке с сильной типизацией?

Посмотрим на С++ и Go.

Начнём с C++.

За Go - идём [сюда](https://ideone.com/FxMRWF).
"""